* partial-recall

#+BEGIN_HTML
<a href='https://coveralls.io/github/Walheimat/partial-recall?branch=trunk'>
    <img
        src='https://coveralls.io/repos/github/Walheimat/partial-recall/badge.svg?branch=trunk'
        alt='Coverage Status'
    />
</a>
#+END_HTML

=partial-recall= provides a narrow buffer scope built on top of
=tab-bar-mode=. It turns each tab into a living (that is: forgetful)
workspace. Each file buffer that is first visited in a tab will be
associated with that tab until a limit is met whereupon the oldest
buffer is forgotten. If a newly visited buffer is already associated
with another tab, it may be reclaimed (automatically or manually). If
all buffers were visited relatively recently, the size of the limit
increases (for that tab).

** Installation

If you use =straight= or =quelpa=, you know what to do.

If you're on Emacs >29, I recommend using =package-vc-install=.

Alternatively, provided you have Cask, you can install the package
with =make package-install=.

** Configuration

=partial-recall= will turn on =tab-bar-mode= if it isn't already turned
on. =partial-recall-mode= will make sure all newly created frames are
taken into account.

#+begin_src emacs-lisp
(use-package partial-recall
  :custom
  (partial-recall-buffer-limit 20) ;; The number of buffers in the ring.
  (partial-recall-max-age 300) ;; The age (in seconds) that will allow the ring to grow.
  (partial-recall-reclaim-min-age 600) ;; The age (in seconds) that will allow reclaiming.

  :config
  (partial-recall-mode)

  ;; If you use `consult', you can add the provided buffer source.
  (with-eval-after-load 'consult
    (add-to-list
     'consult-buffer-sources
     'partial-recall--consult-buffer-source))

  :bind
  (("C-c b" . partial-recall-switch-to-buffer))

  :bind-keymap
  (("C-c B" . partial-recall-command-map)))
#+end_src
